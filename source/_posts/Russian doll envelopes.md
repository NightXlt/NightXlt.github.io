title:  Russian doll envelopes
date: 2019-1-10
tags: [Leetcode,å­—èŠ‚è·³åŠ¨]
categories: algorithm

description: Find the maximum number of envelopes can you Russian doll? (put one inside other)
---
## Problem description
You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.

What is the maximum number of envelopes can you Russian doll? (put one inside other)

Note:Rotation is not allowed.

 ## Examples
``` java
Example 1:
Input: [[5,4],[6,4],[6,7],[2,3]]
Output: 3 
Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).
```
## Solution
ã€€ã€€ è¿™æ˜¯ä¸€ä¸ªäºŒç»´LISï¼ˆLongest Increasing Subsequenceï¼‰é—®é¢˜ï¼Œå¯ä»¥é€šè¿‡å…ˆä»¥å®½åº¦è¿›è¡Œé€’å¢žæŽ’åºä»Žè€Œé™ç»´å¤„ç†ï¼Œå³å®½åº¦æœ‰åºä»…éœ€å¤„ç†é•¿åº¦å³å¯ã€‚å†æ±‚é•¿åº¦æœ€é•¿é€’å¢žå­åºåˆ—ï¼Œæ³¨æ„çš„æ˜¯å½“å®½åº¦ç›¸åŒæ—¶ï¼Œè¦å–é•¿åº¦æœ€å°çš„åºåˆ—ã€‚æœ‰ä¸€ç‚¹è´ªå¿ƒçš„æ€æƒ³ã€‚é•¿åº¦è¶Šå°ï¼Œå¯æ”¾å…¥çš„ä¿¡å°ç›¸åº”çš„ä¹Ÿå°±è¶Šå¤šã€‚   
ã€€ã€€æ±‚é€’å¢žå­åºåˆ—é•¿åº¦æ—¶ä¸èƒ½ç›´æŽ¥åŒå±‚éåŽ†O(n^2)ï¼Œå¯é€šè¿‡äºŒåˆ†æŸ¥æ‰¾æ¥æŸ¥æ‰¾é™ä½Žä¸ºO(nlogn)ã€‚~~è¿™é‡ŒäºŒåˆ†çš„æ€æƒ³æœ‰äº›å¥¥å¦™ã€‚å…ˆæ˜¯åˆ›å»ºHæ•°ç»„å­˜å‚¨"å­åºåˆ—çš„"æœ€å¤§é€’å¢žå­åºåˆ—çš„æœ«å°¾å…ƒç´ ã€‚é€šè¿‡äºŒåˆ†æŸ¥æ‰¾Hæ•°ç»„ä¸­å…ƒç´ ï¼ˆåŽŸæ•°ç»„ä¸­çš„æœ€å¤§é€’å¢žå­åºåˆ—çš„æœ€æœ«å…ƒç´ ï¼‰å°äºŽaiçš„é•¿åº¦æœ€å¤§çš„æœ€å¤§é€’å¢žå­åºåˆ—ï¼›å†ä»¤H[low] = ai.å°†é•¿åº¦ä¸ºlowçš„æœ€å¤§é€’å¢žå­åºåˆ—çš„æœ«å°¾å…ƒç´ ç½®ä¸ºaiã€‚å¦‚æžœlow ç­‰äºŽlenthçš„è¯ï¼Œæ„å‘³ç€æœ€é•¿é€’å¢žåºåˆ—çš„é•¿åº¦ä¸º low + 1ï¼Œæ‰€ä»¥length++ã€‚~~

### LIS

ä¸Šé¢å†™çš„éƒ½æ˜¯é”¤å­å‘€ï¼Œä¸€å¹´åŽå†æ¥çœ‹å®Œå…¨çœ‹ä¸æ‡‚ã€‚åªèƒ½çœ‹é¢˜è§£ä¸€æ­¥æ­¥è·Ÿç€åˆ†æžã€‚åšè¿™é“ä¹‹å‰å…ˆåŽ»åšäº†[æœ€é•¿é€’å¢žå­åºåˆ—](https://leetcode-cn.com/problems/longest-increasing-subsequence/) ï¼Œå®ƒæ˜¯æœ¬é¢˜çš„åŸºç¡€ã€‚

é¦–å…ˆåˆ†æž`æœ€é•¿é€’å¢žå­åºåˆ—`çš„è§£æ³•ï¼Œé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªæ— åºçš„æ•°ç»„æ‰¾åˆ°æœ€é•¿çš„é€’å¢žå­åºåˆ—é•¿åº¦ã€‚é‚£æ€Žä¹ˆåŽ»æ‰¾åˆ°è¿™ä¸ªåºåˆ—å‘¢ï¼Ÿ

> å¦‚æžœæˆ‘ä»¬è¦ä½¿ä¸Šå‡å­åºåˆ—å°½å¯èƒ½çš„é•¿ï¼Œåˆ™æˆ‘ä»¬éœ€è¦è®©åºåˆ—ä¸Šå‡å¾—å°½å¯èƒ½æ…¢ï¼Œå› æ­¤æˆ‘ä»¬å¸Œæœ›æ¯æ¬¡åœ¨ä¸Šå‡å­åºåˆ—æœ€åŽåŠ ä¸Šçš„é‚£ä¸ªæ•°å°½å¯èƒ½çš„å°ã€‚

æˆ‘ä»¬ç”¨ä¸€ä¸ªæ•°ç»„dåŽ»è®°å½•æ¯ä¸ªlen ä¸‹çš„æœ€åŽçš„é‚£ä¸ªæ•°ï¼Œå¹¶é€šè¿‡äºŒåˆ†çš„ç­–ç•¥ä¸æ–­å¾€d æ•°ç»„ä¸­æ›´æ–°æ›´å°çš„æ•°ï¼Œæˆ–è€…è¿½åŠ æ›´å¤§çš„æ•°åœ¨æ•°ç»„æœ«å°¾ã€‚äºŒåˆ†æ›´æ–°æœ€å°çš„æ•°æ˜¯å¸Œæœ›è¿™ä¸ªåºåˆ—èƒ½å¤Ÿå¢žé•¿çš„å°½å¯èƒ½çš„æ…¢ã€‚ d[i]ï¼šè¡¨ç¤ºæ•°ç»„ä¸­ é•¿åº¦ä¸ºiçš„å­åºåˆ—ä¸­æœ€æœ«å°¾çš„å…ƒç´ ã€‚[æ­¤å¤–é¢˜è§£ä¸­æœ‰æ±‚è¯ d æ•°ç»„å’Œå…¶ä¸‹æ ‡å…³ç³»æ˜¯ä¸¥æ ¼é€’å¢žçš„å…³ç³»](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/)ã€‚

ä»¥é¢˜è§£ä¸­çš„è¾“å…¥åºåˆ— [0, 8, 4, 12, 2] ä¸ºä¾‹ï¼š

ç¬¬ä¸€æ­¥æ’å…¥ 0ï¼Œd = [0]

ç¬¬äºŒæ­¥æ’å…¥ 8ï¼Œd = [0, 8]

ç¬¬ä¸‰æ­¥æ’å…¥ 4ï¼Œd = [0, 4]

ç¬¬å››æ­¥æ’å…¥ 12ï¼Œd = [0, 4, 12]

ç¬¬äº”æ­¥æ’å…¥ 2ï¼Œd = [0, 2, 12]

ç»†å¿ƒçš„ä½ æƒ³å¿…æ³¨æ„åˆ°äº†ï¼Œè¿™ä¸ªæ–¹æ³•åªèƒ½æ‰¾åˆ°æœ€å¤§é€’å¢žå­åºåˆ—çš„é•¿åº¦ï¼Œå¹¶ä¸èƒ½æ‰¾åˆ°å…·ä½“çš„æœ€å¤§é€’å¢žå­åºåˆ—ã€‚ æŽ¥ä¸‹æ¥çš„æœ¬é¢˜å°±å’Œä¹‹å‰è®°å½•çš„ä¸€è‡´äº†ã€‚å¯¹äºŒç»´çš„ LIS è¿›è¡ŒæŽ’åºé™ç»´ï¼Œæ³¨æ„å¯¹å®½åº¦é€’å¢žï¼Œä½†æ˜¯å®½åº¦ç›¸åŒæ—¶å¯¹é«˜åº¦éœ€è¦é€’å‡ã€‚

ä¸¾ä¸ªðŸŒ°ï¼Œ[[2ï¼Œ3]ï¼Œ[1ï¼Œ4]ï¼Œ[1ï¼Œ3]ï¼Œ[1ï¼Œ5]] éƒ½è¿›è¡Œé€’å¢žæŽ’åºåŽå¾—åˆ° [[1ï¼Œ3]ï¼Œ[1ï¼Œ4]ï¼Œ[1ï¼Œ5]ï¼Œ[2ï¼Œ3]] è¿™ä¸ªæ—¶å€™æˆ‘ä»¬å¯¹ height åš LISä¼šå¾—åˆ° [3, 4, 5]ï¼Œå¯æ˜¯æ³¨æ„å“Ÿ å¥—å¨ƒæ˜¯ä¸å…è®¸æ”¾åœ¨å®½åº¦ç›¸åŒçš„å¥—å¨ƒä¸Šçš„ã€‚ä¸ºäº†é˜²æ­¢è¿™ç§æƒ…å†µï¼ŒæŽ’åºæ—¶å®½åº¦é€’å¢žï¼Œå®½åº¦ç›¸åŒï¼Œé«˜åº¦é€’å‡ã€‚æœ€åŽå¯¹é«˜åº¦ åš LIS å³å¯ã€‚

ç±»ä¼¼çš„é¢˜ç›®è¿˜æœ‰[é©¬æˆå›¢äººå¡”](https://leetcode-cn.com/problems/circus-tower-lcci/)

åšç¬”è®°æ—¶è¦è®¤çœŸå‘€, åšç¬”è®°æ—¶è¦è®¤çœŸå‘€, åšç¬”è®°æ—¶è¦è®¤çœŸå‘€.äº‰å–åšä¸€é“ä¼šä¸€ç±»å§

æ—¶é—´å¤æ‚åº¦ï¼š $O(nlogn)$

ç©ºé—´å¤æ‚åº¦ï¼š $O(n)$

## Code

```java
 class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        Arrays.sort(envelopes, ((o1, o2) -> {
            if (o1[0] != o2[0]) {
                return o1[0] - o2[0];
            }
            return o2[1] - o1[1];//select lower height
        }));

        int len = 0;
        int[] h = new int[envelopes.length];
        int low, high ,m;
        for (int[] envelope : envelopes) {
            low = 0;
            high = len - 1;
            while (low <= high) {
                m = (low + high) / 2;
                if ((h[m] < envelope[1])) {
                    low = m + 1;
                } else {
                    high = m - 1;
                }
            }
            h[low] = envelope[1];
            if (low == len) {
                len++;
            }
        }
        return len;
    }
}
```