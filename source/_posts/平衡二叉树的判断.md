title: 平衡二叉树的判断
date: 2019-3-6
tags: [Leetcode,剑指Offer]
categories: algorithm
description: 指针讷，指针
---
## Problem description
  ### 输入一棵二叉树的根结点，判断该树是不是平衡二叉树。如果某二叉树中任意结点的左右子树的深度相差不超过1 ，那么它就是一棵平衡二叉树。
 ## Examples
``` java
Example 1:
Input:[3,9,20,null,null,15,7]
Output: true
```
## Solution
思路是采用递归的后序遍历，避免重复访问子树。因为浅拷贝的存在，导致传入的参数一旦赋值，实参并不会跟着发生变化。我想了很久怎么实现指针的引用，竟然还想到写一个返回类封装.....
`数组` 是个好东西讷！它传入的引用一旦发生改变，形参所指向的地址的数据也同样会发生改变。总觉得还遇到过这样的处理方法一次。`谨记，谨记，谨记。`

## Code

```java
 class Solution {
      public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        return isBalanced(root, new int[1]);
    }

    public boolean isBalanced(TreeNode root, int[] depth) {
        if (root == null) {
            depth[0] = 0;
            return true;
        }

        int[] left = new int[1];
        int[] right = new int[1];

        if (isBalanced(root.left, left) && isBalanced(root.right, right)) {
            int d = Math.abs(left[0] - right[0]);
            if (d <= 1) {
                depth[0] = 1 + ((left[0] > right[0]) ? left[0] : right[0]);
                return true;
            }
        }
        return false;
    }
}
```